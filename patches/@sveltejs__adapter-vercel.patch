diff --git a/index.js b/index.js
index d4ec606663b0e2bdbd0b1a3f5a3e4bdf38323020..9f8d275e4db4d53ac939ece856f700b1e0b139ae 100644
--- a/index.js
+++ b/index.js
@@ -51,6 +51,8 @@ const get_default_runtime = () => {
 // https://vercel.com/docs/functions/edge-functions/edge-runtime#compatible-node.js-modules
 const compatible_node_modules = ['async_hooks', 'events', 'buffer', 'assert', 'util'];
 
+const dir = '.vercel/output';
+
 /** @type {import('./index.js').default} **/
 const plugin = function (defaults = {}) {
 	if ('edge' in defaults) {
@@ -68,7 +70,6 @@ const plugin = function (defaults = {}) {
 				);
 			}
 
-			const dir = '.vercel/output';
 			const tmp = builder.getBuildDirectory('vercel-tmp');
 
 			builder.rimraf(dir);
@@ -632,41 +633,74 @@ function static_vercel_config(builder, config, dir) {
 		}
 	];
 
+	// TODO: avoid proxying request if page is on first load
 	// https://vercel.com/docs/deployments/skew-protection
 	if (process.env.VERCEL_SKEW_PROTECTION_ENABLED) {
-		routes.push({
-			src: '/.*',
-			has: [
-				{
-					type: 'header',
-					key: 'Sec-Fetch-Dest',
-					value: 'document'
-				}
-			],
-			headers: {
-				'Set-Cookie': `__vdpl=${process.env.VERCEL_DEPLOYMENT_ID}; Path=${builder.config.kit.paths.base}/; SameSite=Strict; Secure; HttpOnly`
-			},
-			continue: true
-		});
+		fs.writeFileSync(
+			`${dir}/service-worker.js`,
+			`
+const CACHE = "__SVELTEKIT_VERCEL_SKEW_PROTECTION__";
+
+const CACHE_KEY = "/_app/vercel-skew-protection";
+
+const VERCEL_DEPLOYMENT_ID = "${process.env.VERCEL_DEPLOYMENT_ID}";
+
+self.addEventListener("install", (event) => {
+  self.skipWaiting();
+});
+
+async function update_cache(client_id) {
+	let client_map;
+	let response;
+
+	if (client_id) {
+		client_map = { [client_id]: VERCEL_DEPLOYMENT_ID };
+	} else {
+		const client_ids = await clients.matchAll({ type: "all", includeUncontrolled: true });
+		client_map = Object.fromEntries(client_ids.map((client) => [client.id, VERCEL_DEPLOYMENT_ID]));
+	}
 
-		// this is a dreadful hack that is necessary until the Vercel Build Output API
-		// allows you to set multiple cookies for a single route. essentially, since we
-		// know that the entry file will be requested immediately, we can set the second
-		// cookie in _that_ response rather than the document response
-		const base = `${dir}/${builder.config.kit.appDir}/immutable/entry`;
-		const entry = fs.readdirSync(base).find((file) => file.startsWith('start.'));
+	const cache = await caches.open(CACHE);
+	const previous = await cache.match(CACHE_KEY);
 
-		if (!entry) {
-			throw new Error('Could not find entry point');
+	if (previous) {
+		const data = await previous.json();
+		for (const key in client_map) {
+			if (key in data) {
+				client_map[key] = data[key];
+			}
 		}
+	}
 
-		routes.splice(-2, 0, {
-			src: `/${builder.getAppPath()}/immutable/entry/${entry}`,
-			headers: {
-				'Set-Cookie': `__vdpl=; Path=/${builder.getAppPath()}/version.json; SameSite=Strict; Secure; HttpOnly`
-			},
-			continue: true
-		});
+	await cache.put(CACHE_KEY, Response.json(client_map));
+
+	return client_map[client_id] ?? VERCEL_DEPLOYMENT_ID;
+}
+
+self.addEventListener("activate", (event) => {
+	event.waitUntil(
+    (async () => {
+			await clients.claim();
+			await update_cache();
+    })()
+  );
+});
+
+self.addEventListener("fetch", (event) => {
+  event.respondWith(
+    (async () => {
+			const cache = await caches.match(CACHE_KEY);
+			let deployment_id = cache ? (await cache.json())[event.clientId] : await update_cache(event.clientId);
+			return fetch(
+				new Request(event.request, {
+					headers: { "x-deployment-id": deployment_id },
+				})
+			)
+		})()
+  );
+});
+		`.trim()
+		);
 	}
 
 	routes.push({
